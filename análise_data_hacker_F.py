# -*- coding: utf-8 -*-
"""Análise profissão de dados.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qmye5u5MzqWBetOdprn3KKlutHdrX13Y
"""

#Versão da linguagem Python utilizada nesse projeto
from platform import python_version
print("Versão do Python utilizado nesse projeto:", python_version())

"""##**Relatório sobre perfil dos profissionais de dados**

**A pesquisa é formada por diversas perguntas e foi conduzida de forma online durante o mês de novembro de 2019 em vários estados do Brasil**. 

**A realização dessa análise tem como objetivo verificar algumas características dos profissionais da área de dados: Grau de escolaridade, principais ferramentas e metódos utilizados no dia a dia, faixa salarial e demais informações!**

**A confecção dessa análise foi realizada durante aula de Python no curso DDD da Flai curso Data Science**






"""

#instalando pacote pandas profiling para gerar o relatório
!pip install pandas-profiling

#importando demais pacotes
import pandas as pd
from pandas_profiling import ProfileReport
import matplotlib.pyplot as plt
import seaborn

#importando dataset
df = pd.read_csv('/content/datahackers-survey-2019-anonymous-responses.csv', delimiter= ',')

"""Link fonte dataset: https://www.kaggle.com/datahackers/pesquisa-data-hackers-2019"""

#Verificar as primeiras linhas do dataset

df.head()

#Descrição dos dados em colunas no dataset
df.describe()

##Pandas Profiling Relatório com informações gerais sobre o dataset
from pandas_profiling import ProfileReport
profile = ProfileReport(df, title="Relatório análise do dataset", html={'style':{'full_width':True}})
profile.to_notebook_iframe()
profile.to_file(output_file="Relatório análise do dataset")

#mostrar todas as colunas
pd.set_option("display.max_columns", 200)
df.head()

#informações gerais
df.info()

#mostrar percentual de dados que apresentam valores nulos
df.isnull().mean()[ df.isnull().sum() != 0 ].sort_values()

#categorização das profissões
df["('D6', 'anonymized_role')"].value_counts()

#gráfico de barra exibe categoria e quantidade das profissões descritas no dataset
df["('D6', 'anonymized_role')"].value_counts().plot(kind = 'bar')

#tipos de graduação e quantidade de profissionais por curso 
df["('D3', 'anonymized_degree_area')"].value_counts()

#criando um dicionário para selecionar e analisar apenas profissionais de dados
profmap = {'Desenvolvedor ou Engenheiro de Software': 'Desenvolvedor/Engenheiro de Software', 
                                            'Outras': 'Outras',
                 'Data Scientist/Cientista de Dados': 'Cientista de Dados',
                    'Data Analyst/Analista de Dados': 'Analista de Dados',
              'Business Intelligence/Analista de BI': 'Analista de BI',
                 'Data Engineer/Engenheiro de Dados': 'Engenheiro de Dados',
             'Business Analyst/Analista de Negócios': 'Analista de BI',
               'Analista de Inteligência de Mercado': 'Analista de BI',
                                        'Engenheiro': 'Outras',
                             'Analista de Marketing': 'Outras',
                    'Engenheiro de Machine Learning': 'Cientista de Dados',
               'DBA/Administrador de Banco de Dados': 'Engenheiro de Dados',
                                       'Estatístico': 'Cientista de Dados',
                                        'Economista': 'Outras'}

 #criando uma variavel profissão recebendo a coluna D6 do dataset, utilizar .map mapear as profissões no dicionário profmap          
df['profissao'] = df["('D6', 'anonymized_role')"].map(profmap)

df['profissao']

#gráfico com apenas as profissões de dados
df["profissao"].value_counts().plot(kind = 'barh')

#descrição da idade dos profissionais de dados
df["('P1', 'age')"].describe()

#gráfico idade dos profissionais de dados
df["('P1', 'age')"].plot(kind = 'hist', edgecolor = 'black')

# Pré-processamento básico, criando variáveis mais convenientes

# empresa
tammap = { 'de 1 a 5': 'Pequena',
           'de 6 a 10': 'Pequena',
           'de 11 a 50': 'Pequena',
           'de 51 a 100': 'Pequena',
           'de 101 a 500': 'Média',
           'de 501 a 1000': 'Média',
           'de 1001 a 3000': 'Grande',
           'Acima de 3000': 'Grande'}

 
# Faixa de salarios
salamap = {    'Menos de R$ 1.000/mês': 1000,
      'de R$ 1.001/mês a R$ 2.000/mês': 1500, 
       'de R$ 2.001/mês a R$ 3000/mês': 2500,
      'de R$ 3.001/mês a R$ 4.000/mês': 3500,
      'de R$ 4.001/mês a R$ 6.000/mês': 5000, 
      'de R$ 6.001/mês a R$ 8.000/mês': 7000,
     'de R$ 8.001/mês a R$ 12.000/mês': 10000,
    'de R$ 12.001/mês a R$ 16.000/mês': 14000,
    'de R$ 16.001/mês a R$ 20.000/mês': 18000,
    'de R$ 20.001/mês a R$ 25.000/mês': 22500, 
              'Acima de R$ 25.001/mês': 25000}

# discretização da idade (escolha arbitraria dos cortes)
cortes = [0, 24, 30, 40, 100]
#nomes reecebe categoria das idades
nomes = ['[18,24]', '[25,30]', '[31,40]', '[41,50]']

# criando um novo dataset com as informações de maior interesse 

df['idade'] = pd.cut(df["('P1', 'age')"], bins = cortes, labels = nomes)

df['salario'] = df["('P16', 'salary_range')"].map(salamap)  
df['tamanho_da_empresa'] = df["('P12', 'workers_number')"].map(tammap) 

df['gestor'] = df["('P13', 'manager')"].map({0: 'não', 1: 'sim'})
df['se_considera_ds'] = df["('P19', 'is_data_science_professional')"].map({0: 'não', 1: 'sim'})

df['sexo'] = df["('P2', 'gender')"]
df['experiencia_ds'] = df["('P17', 'time_experience_data_science')"]
df['tipo_de_trabalho'] = df["('P10', 'job_situation')"]
df['escolaridade'] = df["('P8', 'degreee_level')"]
df['area_de_formacao'] = df["('D3', 'anonymized_degree_area')"]
df['setor_de_mercado'] = df["('D4', 'anonymized_market_sector')"]
df['plataforma_favorita'] = df["('P35', 'data_science_plataforms_preference')"] 

df.head()

round(df["('P1', 'age')"].mean())

n = df.shape[0]
(df['escolaridade'].value_counts()/n).round(2)

#media salarial dos profissionais de todo o dataset
round(df['salario'].mean(), 2)

#media salarial por profissão e sexo dos profissionais de dados, utilizando .unstack().T, apresenta dados em paralelo.
df.groupby(['sexo','profissao']).mean()['salario'].round(2).unstack().T

#Utilizando .unstack().T para desempilhar as informações, quantidade de profissionais por sexo.
df.groupby(['sexo','profissao']).count()['salario'].round(2).unstack().T

#analisando as informações em um gráfico de barras
df.groupby(['sexo','profissao']).mean()['salario'].round(2).plot(kind = 'bar')

#analisando informações com gráfico de
plt.scatter(df['salario'], df["('P1', 'age')"])

#parametro filter(regex =) é utilizado para filtar as colunas do dataset

df.filter(regex = 'P20').sum().sort_values(ascending = False)

df.filter(regex = 'P21').sum().sort_values(ascending = False)/n

df["('P22', 'most_used_proggraming_languages')"].value_counts()/n

df.filter(regex = 'P27').sum().sort_values(ascending = False)/n

df.groupby('sexo').mean()['salario']

df.groupby(['sexo', 'tamanho_da_empresa']).mean()['salario'].unstack().T

df.groupby('tamanho_da_empresa').mean()['salario']

df.groupby(['sexo', 'tamanho_da_empresa']).mean()['salario'].unstack().T.plot(kind = 'bar', 
                                                                                 color = ['red', 'blue'])

c = df.groupby(['sexo', 'escolaridade']).mean()['salario'].unstack().T
c['F/M'] = c['Feminino']/c['Masculino'] 
c

c = df.groupby(['sexo', 'idade']).mean()['salario'].unstack().T
c['F/M'] = c['Feminino']/c['Masculino'] 
c.round(2)

#criando conjuntos de dados convenientes através de alguns filtros

#profissoes de dados
lista = ['Cientista de Dados', 'Analista de Dados', 'Analista de BI', 'Engenheiro de Dados']

pds = df[df['profissao'].isin(lista)]

cds = df[df['profissao'] == 'Cientista de Dados'] 
ads = df[df['profissao'] == 'Analista de Dados'] 
abi = df[df['profissao'] == 'Analista de BI'] 
eds = df[df['profissao'] == 'Engenheiro de Dados']

pds['salario'].mean()

pds.groupby('profissao').mean()['salario'].round(2)

pds.groupby(['profissao', 'sexo']).mean()['salario'].round(2).unstack()

pds.groupby(['profissao', 'idade']).mean()['salario'].round(2).unstack()

pds.groupby(['profissao', 'experiencia_ds']).mean()['salario'].round(2).unstack()

cds.groupby(['experiencia_ds']).count()['salario'].round(2)

pds.groupby(['profissao', "('P22', 'most_used_proggraming_languages')"]).mean()['salario'].round(2).unstack().T

#metodos mais utilizados
 

aux1 = round(cds.filter(regex = 'P20').sum().sort_values(ascending = False)/cds.shape[0], 2)   
aux2 = round(ads.filter(regex = 'P20').sum().sort_values(ascending = False)/ads.shape[0], 2)   
aux3 = round(abi.filter(regex = 'P20').sum().sort_values(ascending = False)/abi.shape[0], 2)  
aux4 = round(eds.filter(regex = 'P20').sum().sort_values(ascending = False)/eds.shape[0], 2)  

aux = pd.concat([aux1, aux2, aux3, aux4], axis = 1)
aux.columns = lista

aux.sort_values(by = 'Cientista de Dados', ascending = False)

#linguagens mais utilizados
 

aux1 = round(cds.filter(regex = 'P21').sum().sort_values(ascending = False)/cds.shape[0], 2)   
aux2 = round(ads.filter(regex = 'P21').sum().sort_values(ascending = False)/ads.shape[0], 2)   
aux3 = round(abi.filter(regex = 'P21').sum().sort_values(ascending = False)/abi.shape[0], 2)  
aux4 = round(eds.filter(regex = 'P21').sum().sort_values(ascending = False)/eds.shape[0], 2)  

aux = pd.concat([aux1, aux2, aux3, aux4], axis = 1)
aux.columns = lista

aux.sort_values(by = 'Engenheiro de Dados', ascending = False)

#ferramentas mais utilizadas
 

aux1 = round(cds.filter(regex = 'P27').sum().sort_values(ascending = False)/cds.shape[0], 2)   
aux2 = round(ads.filter(regex = 'P27').sum().sort_values(ascending = False)/ads.shape[0], 2)   
aux3 = round(abi.filter(regex = 'P27').sum().sort_values(ascending = False)/abi.shape[0], 2)  
aux4 = round(eds.filter(regex = 'P27').sum().sort_values(ascending = False)/eds.shape[0], 2)  

aux = pd.concat([aux1, aux2, aux3, aux4], axis = 1)
aux.columns = lista

aux.sort_values(by = 'Cientista de Dados', ascending = False)

cds[cds["('P21', 'python')"] == 1]['salario'].describe()

cds[cds["('P21', 'r')"] == 1]['salario'].describe()

cds[cds["('P21', 'sql_')"] == 1]['salario'].describe()

# APENAS PYTHON
cds[(cds["('P21', 'python')"] == 1) & (cds["('P21', 'r')"] == 0) & (cds["('P21', 'sql_')"] == 0)]['salario'].describe()

# APENAS R
cds[(cds["('P21', 'python')"] == 0) & (cds["('P21', 'r')"] == 1) & (cds["('P21', 'sql_')"] == 0)]['salario'].describe()

# APENAS SQL
cds[(cds["('P21', 'python')"] == 0) & (cds["('P21', 'r')"] == 0) & (cds["('P21', 'sql_')"] == 1)]['salario'].describe()

# APENAS PYTHON E R
cds[(cds["('P21', 'python')"] == 1) & (cds["('P21', 'r')"] == 1) & (cds["('P21', 'sql_')"] == 0)]['salario'].describe()

# APENAS PYTHON E SQL
cds[(cds["('P21', 'python')"] == 1) & (cds["('P21', 'r')"] == 0) & (cds["('P21', 'sql_')"] == 1)]['salario'].describe()

# APENAS R E SQL
cds[(cds["('P21', 'python')"] == 0) & (cds["('P21', 'r')"] == 1) & (cds["('P21', 'sql_')"] == 1)]['salario'].describe()

# TODOS
cds[(cds["('P21', 'python')"] == 1) & (cds["('P21', 'r')"] == 1) & (cds["('P21', 'sql_')"] == 1)]['salario'].describe()

# distribuicao do salario dos Cientistas de Dados que declararam usar R e não usar Python.
cds[(cds["('P21', 'python')"] == 0) & (cds["('P21', 'r')"] == 1)]['salario'].describe()

# distribuicao do salario dos Cientistas de Dados que declararam usar Python e não usar R.
cds[(cds["('P21', 'python')"] == 1) & (cds["('P21', 'r')"] == 0)]['salario'].describe()

# distribuicao do salario dos Cientistas de Dados que declararam usar R e Python.
cds[(cds["('P21', 'python')"] == 1) & (cds["('P21', 'r')"] == 1)]['salario'].describe()

# distribuicao do salario dos Cientistas de Dados que declararam não usar R nem Python.
cds[(cds["('P21', 'python')"] == 0) & (cds["('P21', 'r')"] == 0)]['salario'].describe()